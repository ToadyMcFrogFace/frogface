<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script src="jquery.min.js"></script>
</head>
<body>

	<button id="guess">clicky click mother fucker</button>

	<h1 id="print"></h1>

	<div id="grid">
		
	</div>
	
</body>
</html>





<script>

	// build arena

	var grid_span = 10;

	// spawn
	var point = {
		x: 3,
		y: 4
	};

	var axes = ['x', 'y'];

	var gems = [];
	var flys = [];
	var frogs = [];

	var gem = function(x, y) {
		// constructor
		this.element = document.createElement('div');
		this.element.dataset.x = x;
		this.element.dataset.y = y;
		this.element.dataset.xy = 'x'+x+'y'+y;
		this.element.className = 'gem';
		this.coordinates = {x:x,y:y};
		$('#grid').append(this.element);

		gems.push(this);
	}

	var fly = function() {

		// todo:: name --> coordinate 
		this.gem = {x:spawn(), y:spawn()}

		this.move = function() {
			var newpos = [];

			for (var key in this.gem) {
				if(this.gem.hasOwnProperty(key)) {
					var dir = axisDir();
					// test if in parameters else don't move

					newpos[key] = this.gem[key];

					if(newpos[key] + dir <= grid_span && newpos[key] + dir > 0 ) {
						newpos[key] += dir;
					}
				}
			}

			if(this.gem != newpos) {
				$(plotToGem(this.gem)).removeClass('player');
				this.gem = newpos;
				$(plotToGem(this.gem)).addClass('player');
				// log(this.position);
				// this.animate_step();
			}

		}

		this.animate_step = function() {
			$(plotToGem(this.gem)).addClass('player');
		}

		function spawn() {

			return (Math.floor(Math.random() * 10) + 1);
		}
		// move() ??
		function axisDir() {

			return (Math.floor(Math.random() * 3)) - 1;
		}
	}

	var frog = function() {
		this.memory = [];
		this.memory.push({'flyGem':flys[0]['gem'],'flyMovement':{x:0,y:0}});
		this.memoryStrings = {'flyGem':{x:'|'+flys[0]['gem']['x'],y:'|'+flys[0]['gem']['y']},'flyMovement':{x:'|0',y:'|0'}};

		this.buildMemory = function() {
			var memoryObj = {};
			var flyMovementObj = flyMovement(flys[0]['gem'], this.memory[this.memory.length - 1]['flyGem']); 
			// var pushit = {x:0,y:0]

			memoryObj['flyGem'] = flys[0]['gem'];
			// console.log(flys[0]['gem']);
			memoryObj['flyMovement'] = flyMovementObj;

			this.memoryStrings.flyGem.x += flys[0]['gem']['x'] + '|';
			this.memoryStrings.flyGem.y += flys[0]['gem']['y'] + '|';
			this.memoryStrings.flyMovement.x += flyMovementObj['x'] + '|';
			this.memoryStrings.flyMovement.y += flyMovementObj['y'] + '|';

			this.memory.push(memoryObj);

			stringSearch(this.memoryStrings.flyMovement.x);

		}

		function flyMovement(gem, fromGem) {
			// console.log(gem);
			// console.log(fromGem);
			movement = [];
			for(var i = 0; i < axes.length; i++) {
				movement[axes[i]] = gem[axes[i]] - fromGem[axes[i]];
			}
			return movement;
		}

		this.guess = function() {
			var newpos = [];
			var guess = [];

			// for (var key in this.memory) {
			// 	if (this.memory.hasOwnProperty(key)) {
			// 		var total = 0;

			// 		// tring to get last 10 memories
			// 		 // not 100's if wrkin
			// 		for(var i = this.memory[key].length; i > 0 && i > this.memory[key].length-10 ; i--) {
			// 			total += this.memory[key][i-1];
			// 		}

			// 		total += (Math.floor(Math.random() * 10) + 1);

			// 		// get the average. axis guess
			// 		// toPos
			// 		guess[key] = Math.round( total / (this.memory[key].length + 1) );

			// 		if(flys[0]['gem'][key] == guess[key]) {
			// 			newpos[key] = guess[key];
			// 			this.memory[key].push(guess[key]);
			// 		}
			// 	}
			// }

			if(guess.length > 0) {

			}

			// Direct Hit
			// console.log(guess);
			// if hit
			// if(newpos[x] > 1 && newpos[y] > 1) {
				// alert('its its');
				$(plotToGem(this.memory)).addClass('hit');
			// }
		}
	}

	// frog.prototype.memory = [{'flyGem':flys[0],'flyMovement':{x:0,y:0}}];

	// memory analysis 
	function stringSearch(str) {
		var pattern;
		// var oc
		for (var i = str.length; i >= 0; i--) {
			if(str.substring((i-1), i) == '|') {
				testPattern = str.substring((i-1), str.length);
				if(testPattern!='|') {
					// console.log('testPattern: ' +testPattern);
					// console.log('str: ' +str);
					oc = occurrences(str, testPattern, true);
					if(oc <= 1) {
						break;
					}
					log('i: ' + i);
					log(oc);
					pattern = testPattern;
					// popPipe(oc);
				}
			}
		}
	}

	/** Function that count occurrences of a substring in a string;
	 * @param {String} string               The string
	 * @param {String} subString            The sub string to search for
	 * @param {Boolean} [allowOverlapping]  Optional. (Default:false)
	 * @author Vitim.us http://stackoverflow.com/questions/4009756/how-to-count-string-occurrence-in-string/7924240#7924240
	 */
	function occurrences(string, subString, allowOverlapping) {

	    string += "";
	    subString += "";
	    if (subString.length <= 0) return (string.length + 1);

	    var n = 0,
	        pos = 0,
	        step = allowOverlapping ? 1 : subString.length,
	        prediction = [];

	    while (true) {
	        pos = string.indexOf(subString, pos);
	        if (pos >= 0 && (pos + subString.length != string.length)) {
	        	var po = popPipe(string.substring(pos + subString.length, string.length), 0);
	        	// log(po);

	        	prediction.push(po);
	            // n.push(string.substring(pos + subString.length, pos + subString.length + 1));
	            ++n
	            pos += step;
	        } else break;
	    }
	    return prediction;
	}

	function popPipe(str, index) {
		var array = str.split('|');
		return array[index];
	}

	// tryingToGroupFlys() {

	// 	var wrd = new flys();
	// 	wrd.forEachFly (function () { // forEach abstraction
	// 		this.move();
	// 	});
	// 	var flys = function() {
	// 		this.allFlys = [];
	// 		this.createFlys = function() {
	// 			this.allFlys.push(new fly());
	// 		}

	// 		this.forEachFly =  function (action) {
	// 			for (var i = 0; i < this.allFlys.length; i++) {
	// 		    	action.call(this.allFlys[i]);
	// 	    	}
	// 		}
	// 	}

	// 	var world = new flys();

	// 	world.createFlys();

	// 	CatFactory.forEachCat (function () { // forEach abstraction
	// 	  alert(this.name + ' is ' + this.color);
	// 	});
	// }

	var flys = [new fly()];
	var druid = new frog();

	$('#guess').on('click', function() {
		// log(flys);
		for(var i = 0; i < flys.length; i++) {
			flys[i].move();
		}
		druid.buildMemory();
	});

	// setInterval(function(){ 

	// 	druid.guess();

	// }, 100);

	for(var y = grid_span; y > 0; y--) {
		for(var x = grid_span; x > 0; x--) {
			gems.push(new gem(x,y));
		}
	}

	function log(i) {
		console.log(i);
	}

	function plotToGem(coordinates) {
		var gem = '[data-xy="{{}}"]';
		var plot = '';
		for (var key in coordinates) {
			if(coordinates.hasOwnProperty(key)) { 
				plot += key+coordinates[key];
			}
		}
		plot = gem.replace('{{}}', plot);
		return plot;
	}

</script>

<style>
	.gem {
		width: 20px;
		height: 20px;
		background-color: red;
		margin: 2px;
		float: right;
	}

	.gem:nth-child(10n + 11) {
		clear: both;
	}

	.player {
		background-color: black !important; 
	}

	.hit {
		background-color: purple !important; 
	}
</style>


